---
title: '[R] 자료 구조'
author: Jay
date: '2020-09-17'
slug: r-자료-구조
categories:
  - Data Type & Structure
tags:
  - R Markdown
description: ''
topics: []
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

 기본적으로 모든 프로그래밍 언어가 조금씩 다른 자료 구조를 가지고 있다. 여기서는 분석에서 사용에 필요한 기본적인 R의 자료형과 자료구주에 대해서 정리한다.




# R 자료형

 R이 가지는 자료형(Data Type)은 크게 숫자, 문자, 논리, 팩터, 날짜 등으로 크게 5가지 형태로 구분된다.(물론 이외에도 날짜를 나타내는 형태와 더 많은 자료형이 있지만 여기서는 기본적인 네가지만을 다루기로 한다.)

## 1. 수치형(Numeric Type)

 먼저 수치형은 Numeric이라고 불리며 우리가 흔히 알고 있는 숫자를 나타낸다. 수치형 또 정수, 실수, 허수, 복소수 등으로 세분화 되는데 이미 중고등과정 내에서 학습된 내용이기 때문에 추가적인 설명은 생략한다. 아래 numeric_1은 정수를, numeric_2는 실수를, numeric_3은 허수를 numeric_4는 실수와 허수가 더해진 복소수를 나타낸다.

```{r}
numeric_1<- 1
numeric_2<- 2.4
numeric_3<- 2i
numeric_4<- 2.4 +2i
```


## 2. 문자형(Character Type)

 문자형은 말그대로 문자를 나타내며 우리가 쓰는 언어부터 모든 특수기호와 숫자등 ' 혹은 "로 둘러싸인 모든 자료형을 뜻한다. 여기서 
'(apostrophe)와 "(quotation mark)의 차이는 존재하지 않는다. 문자형은 모든 자료형을 아우르는 가장 포괄적인 개념으로 어떤 자료형이라도 '(apostrophe)나 "(quotation mark)로 나타내어 진다면 문자로 인식한다. 따라서 1은 숫자형이지만 '1' 혹은 "1"은 문자형이다. 유의할 사항은 대소문자 구별을 확실히 해야한다는 것이다.

```{r}
character_1<- 'R'
character_2<- '1'
character_3<- '&'
  
```


## 3.논리형(Logical Type)

 논리형은 참, 거짓이라는 컴퓨터에 가장 기본이 되는 자료형으로 TRUE, FALSE 두가지 값만을 가진다. 언어별로 대소문자가 조금씩 다르지만 R에서는 크게 TRUE, FALSE와 같이 모두 대문자로 쓰거나 앞글자인 T, F 혹은 FALSE를 0 나머지 숫자를 그 외 모든 숫자로 해서 사용할수 있다. '(apostrophe)와 "(quotation mark)를 문자로 인식하기 때문에 사용하면 안된다.
 
```{r}
logical_1<- TRUE
logical_2<- F
logical_3<- as.logical(0)
  
logical_4<- as.logical(11111)
```

## 4.Factor형(Categorical Type)

 Factor형은 R에서만 존재하는 특이한 자료형으로 범주형(명목, 순서) 변수를 나타낼수 있는 자료형이다. 인종 등과 같이 황인, 백인, 흑인 범주로 구분되는 경우와 범주이나 순서가 존재하는 성적으로 구분되는 우등반 열등반 같은 형태로 구분하기 위해서 사용된다. 보통 데이터를 불러올때 String을 Factor로 자동 인식해서 가져오던가 문자형인 변수를 팩터로 지정해서 사용가능하다.   

```{r}
factor_1 <- c('황인','백인','흑인')
factor_1 <-as.factor(factor_1)
factor_2 <- c("우등반", "열등반")
factor_2 <- factor(factor_2, levels=c("열등반", "우등반"), ordered=T)
# 순서형 범주로 바꾸고 싶은 경우 as.factor가 아니라 factor를 사용해야 함.
```

## 5. Date 자료형(Date Type)

 Date 자료형 날짜 자료형은 날짜를 표현하기 위해서 사용되는 형태로 형식을 지정하여 사용할수 있습니다. 기본적으로 R에서 제공하는 날짜 자료형은 일 단위까지 표시되며, 추가적으로 시간 단위까지 사용하기 위해서는 POSIXct, POSIXlt 클래스를 사용해야 한다. 또 날짜형 자료의 구성요소인 시간, 날짜 등을 가져오기 위해서는 lubridate 패키지를 활용해야 한다.
 
```{r}
date_0 <- Sys.Date()
date_1 <- as.Date("13-07-2020",format="%d-%m-%Y")
date_2 <- as.Date(3,origin="2020-07-10")  #기준 날짜로 부터 3일 후
date_3 <- Sys.time()
date_4 <- as.POSIXct("2020-07-13 01:00:00")
library(lubridate)
year(date_0)
month(date_4)
hour(date_4)
yday(date_4)
wday(date_4)
```


## 6. NA, NULL 자료형

 NA, NULL등은 특수한 상황에 사용되는 자료형태로 NA는 데이터의 입출력시 해당 자료가 자료형에 맞지 않아 읽을 수 없는 상황에 사용됩니다. 반면 NULL 은 해당 자료가 존재하지 않을때(결측되었을 때) 사용됩니다. 두개가 언뜻 비슷한 의미로 사용되는 것처럼 느껴지지만 NA의 경우는 데이터에 NA라는 값이 존재하고, NULL은 아무것도 존재하지 않을 때 사용됩니다. NA는 Not Available의 약자로 사용할수 없음 을 뜻하고 NULL은 값이 존재할 곳에 아무것도 존재하지 않음을 뜻합니다. 언어마다 사용되는 값이 다소 다르니 명확히 봐두시는 것이 좋습니다. 이 밖에도 R에는 무한대를 뜻하는 Inf와 -Inf 값도 존재합니다. 추가적으로 0으로 나누는 것과 같은 수학적으로 정의가 되지 않는 함수는 Not a Number라는 의미로 NaN으로 정의됩니다.
 
```{r}
etc_1 <- NA 
etc_2 <- NULL
etc_3 <- Inf
etc_4 <- -Inf
etc_5 <- NaN
  
```


위 자료형에 대한 설명이 끝났다면 제대로 자료형이 지정되었는지 이를 확인하는 과정도 필요하다. 그때 사용되는 함수는
class() 함수로 확인할 수 있다. 사용법은 간단하다. 아래 결과를 통해서 알수 있지만 NA, NULL을 제외하고는 모두 숫자형이며, NULL은 그 자체로 NULL을 반환하지만 NA는 논리형을 반환한다.

```{r}
class(numeric_1)
class(character_1)
class(logical_1)
class(factor_1)
class(etc_5)
```



또 각 자료형이 잘못 입력되었다면 서로간에 변형이 가능한데 이때 사용되는 함수는 as.numeric(), as.factor(), as.character(), as.logical() 등의 함수를 사용한다. 이때 주의할 사항은 변수간에 변형이 가능한지 확인하는 것이다. 

모든 자료형은 문자형으로 변환가능하다. 
문자가 숫자로 이루어졌다면 숫자형 변수로 변환가능하다. 
숫자형 변수와 논리형 변수는 서로 변환 가능하다.

```{r}
as.character(numeric_1)
as.factor(character_1)
as.numeric(logical_1)
as.character(factor_1)
```


# R 자료 구조

 위에서 살펴본 자료형 데이터를 기본으로 R의 자료 구조는 스칼라, 벡터, 행렬, 데이터프레임, 어레이, 리스트 총 다섯 가지의 형태의 자료 구조를 가진다.


## 0. 스칼라
 먼저 스칼라는 위에서 살펴본 자료형 데이터 하나 하나를 뜻한다.

## 1. 벡터
 벡터는 R에서 사용하는 자료 구조중 가장 기본이 되는 형태로 스칼라가 나열된 형태이다. 다만 한 벡터 내에는 모두 동일한 자료형의 자료가 존재해야 한다. 예를 들어 문자형과 숫자형을 나란히 연결한다면 이 벡터는 문자형 벡터로 나타나고 벡터내 모든 자료형은 문자형으로 변환된다. 사용법은 c() 함수 내에 모든 변수를 ,로 나열하면 된다.
 
```{r}
vector_1 <- c(1, 2, 3, 4, 5)
vector_2 <- c('일','이', '삼', '사', '오')
vector_3 <- c(TRUE,TRUE,TRUE,FALSE,TRUE)
vector_4 <- c(1, 2,'삼', '사', 5)
```

각 벡터에서 특정 성분을 불러오기 위해서는 인덱스를 사용해야 한다. 다른 컴퓨터 언어와 달리 R의 인덱스는 1부터 시작된다

```{r}
vector_1[1]
vector_2[2:3]
vector_3[c(1,3)]
vector_4[-1:-2]
```


## 2. 행렬: 두 가지 이상의 자료형을 담지 못함.
 벡터 여러개가 합쳐진 형태로 중고등학교때 배운 행렬을 그대로 옮겨놓은 형태이다. 기본적으로 벡터와 비슷한 성질로 모두 동일한 자료형을 가지고 있어야한다. 

```{r}
matrix_1 <- matrix(c(1, 2, 3, 4, 5,6,7,8,9), nrow=3)
matrix_2 <- matrix(c('일','이', '삼', '사', '오','육','칠','팔','구'), nrow=3)
matrix_3 <- matrix(c(TRUE,TRUE,TRUE,FALSE,TRUE,TRUE,TRUE,FALSE,TRUE),nrow=3)
matrix_4 <- matrix(c(1, 2, 3, 4, 5, 6, '칠', '팔', 9), nrow=3)
```
각 행렬에서 특정 성분을 불러오기 위해서는 두개의 인덱스를 사용해야 한다. 

```{r}
matrix_1[1,]
matrix_2[,2]
matrix_3[c(1,3),]
matrix_4[-1:-2,]
```


## 3. 데이터프레임: 엑셀 시트 형태로 일반적인 분석자료의 형태, 다양한 자료형을 담을 수 있음.
 데이터프레임은 엑셀에서 사용하는 시트 형태를 떠올리면 알수 있다. 행렬과 비슷하지만, 열별로 다른 자료형을 담을수 있어 다양한 데이터를 한꺼번에 다룰수 있는 형태이다. 분석을 진행할때 사용하는 가장 기본적인 자료구조이다. 벡터나 행렬의 경우 한 가지 자료형만을 다루고 있지만 실제 데이터에서는 여러가지 자료형을 한꺼번에 사용하게 된다. 따라서 가장 기본적으로 사용하는 형태이다.
 
```{r}
성명 <- c("스파이더맨", "아이언맨", "홍길동")
나이 <- c(20, 30,25)
국적 <- c("미국", "미국", "한국")
dataframe_1<- data.frame( 성명,나이,국적)
dataframe_2 <- data.frame(성명=c("스파이더맨", "아이언맨", "홍길동"), 나이=c(20, 30,25), 국적=c("미국", "미국", "한국"))
```

 데이터 프레임에서 특정 성분을 불러오기 위한 인덱싱은 행렬과 동일하다고 봐도 무방하다. 하지만 보통 행렬의 경우는 숫자 인덱스를 주로 사용하고, 데이터프레임은 행은 그대로, 열이름을 지정하여 열이름으로 불러오는 것을 선호한다. 

```{r}
dataframe_1[1,]
dataframe_2[,2]
dataframe_1[c(1,3),]
dataframe_2[-1:-2,]
dataframe_2$성명
```




## 4. 어레이: 3차원 행렬(행렬을 겹쳐놓은 자료형), 두 가지 이상의 자료형을 담지 못함.
  ex) array_1[1, 2, 1] : 1행, 2열, 1번째 행렬
  
  array는 3차원으로 만들어진 행렬입니다. 행렬에 행을 x축으로 열을 y축으로 했을때 이때 한 개의 축 z(앞으로 이를 깊이로 부르겠다)를 더해진 형태입니다. 행렬의 숫자들이 3차원으로 존재한다고 생각하면 이해가 가실 겁니다. 아주 드물게 사용되기는 하지만 필요할수 있으니 알아두는게 좋을 거라고 생각됩니다. 3차원 행렬이라고 한 이유는 한 자료로만 구성되어 있어야 한다는 조건이 동일하기 때문입니다. dim()함수를 통해서 2행 2열 의 행렬 2(깊이)개가 생성되게 됩니다.
  
```{r}
array_1 <- array(3:18, dim = c(2,2,2))  
array_2 <- array(10:34, dim = c(2,3,4))  
```

 어레이에서 특정 성분을 불러오기 위한 인덱싱은 행렬에서 하나의 인덱싱(깊이)이 추가된 형태입니다. 

```{r}
array_1[1,,]
array_2[,2,]
array_1[c(1,2),,]
array_2[2,1,1]
```



## 5. 리스트: 가장 높은 차원의 자료형 , 다양한 자료형을 담을 수 있음.
  ex) list_1[[4]] = list_1[["데이터프레임"]] = lists_1$"데이터프레임"
  
  리스트는 R에서 사용하는 가장 큰 자료 구조로 데이터프레임을 여러개 합쳐놓은 형태로 생각할수 있습니다. 여러개의 데이터 프레임을 하나의 자료 구조로 표현할때 주로 사용됩니다. 데이터 프레임 만큼은 아니어도 종종 사용되는 자료구조이니 제대로 알아 두는 것이 좋습니다. 사용법은 간단합니다. 어떤 데이터 구조도 list안에 포함될수 있습니다. 심지어 list 안에 list를 담는 것도 가능합니다.
  
  
```{r}
list_1 <- list(dataframe_1, dataframe_2, matrix_1, vector_1)
list_2 <- list("데이터프레임1"=dataframe_1, "데이터프레임2"=dataframe_2, "행렬"=matrix_1, "벡터"=vector_1)
```

 리스트에서 특정 성분을 불러오기 위한 인덱싱은 기존의 인덱싱을 위해서 사용했던 []가 아닌 [[]] 두개를 사용합니다. 다만 여기서 주의할 사항은 첫번째 인덱스 [[1]]는 리스트에 들어있는 값들중 첫번째 값(dataframe_1, dataframe_2, matrix_1, vector_1 ) 중 첫번째인 dataframe_1 을 나타내고, 두번째 인덱스 [[1]][[2]]는 dataframe_1의 두번째 요소 즉 두번째 열을 선택한다는 것입니다. 이때 데이터 프레임은 구성요소중 열을 기준으로 가져오게되고,  인덱싱이 [[4]][[2]]라면 세번째 요소인 vector과 그 성분중 두번째 값인 2가 나온다는 것입니다. 행렬도 벡터와 동일한데 1열 부터 순서가 되는 벡터로 변형하여 순번째 값을 불러오게 됩니다. 물론 리스트 내 요소의 이름을 지정하여 이 값을 불러올수도 있습니다. 이때는 $를 사용합니다. 

```{r}
list_1[[3]]
list_1[[1]][[2]]
list_1[[4]][[2]]
list_1[[3]][[2]]
list_1$행렬
```


위 자료구조에 대한 설명이 끝났다면 자료구조가 옳게 지정되었는지 이를 확인하는 과정도 필요합니다. 그때 사용되는 함수는 class() 함수입니다. 조금 특이한게있다면 벡터는 numeric으로, 행렬의 경우 array의 특별한 형태로 받아들여질수도 있어 행렬과 어레이 둘다 가능하다는 것을 알수 있습니다. 하지만 실제로 분석을 할때 더 자주 사용되는 함수는 str()함수입니다. str()함수는 자료형과 자료 구조를 함께 보여주어 사용하기 편리합니다. 다만, 행렬이나 어레이의 경우 행렬이라고 명시되지는 않고 형태로 이를 유추해야 하는 단점이 있습니다. 하지만 분석상에서 주로 사용되는 자료구조는 데이터프레임과 리스트이기때문에 주로 str() 사용합니다.

```{r}
class(vector_1)
class(matrix_1)
class(dataframe_1)
class(array_1)
class(list_1)
str(vector_1)
str(matrix_1)
str(dataframe_1)
str(array_1)
str(list_1)
```


또 각 자료구조를 바꿔야할 필요가 있다면 서로간에 변형이 가능한데 이때 사용되는 함수는 as.vector(), as.matrix(), as.data.frame(), as.array(), as.list()  등의 함수를 사용합니다. 이때 주의할 사항은 자료들 간에 변형이 가능한지 확인하는 것입니다. 

다른 구조를 벡터로 바꾸는 경우 열을 기준으로 나열한 벡터 행텨로 변형된다.
데이터프레임과 리스트는 벡터로 변환이 불가능하다.

```{r}
as.vector(matrix_1)
as.vector(dataframe_1)
```

다른 자료구조를 행렬로 바꾸는 경우 모든 데이터를 벡터로 변형한 형태에서 행렬로 변환된다.(열부터 채워짐)
데이터프레임을 행렬로 바꾸는 경우 문자가 존재한다면 모든 자료는 문자형으로 변환된다.
리스트를 행렬로 바꾸는 경우 각 데이터의 자료형과 개수와 같은 설명이 행렬로 변환된다.

```{r}
as.matrix(matrix_1)
as.matrix(dataframe_1)
as.matrix(array_1)
as.matrix(list_1)
```

벡터를 데이터 프레임으로 바꾸는 경우 열에 그 값이 배치된다.
행렬을 데이터프레임으로 바꾸는 경우 그대로 데이터 프레임으로 변환된다.
어레이를 데이터프레임으로 바꾸는 경우 3차원의 값을 2차원으로 줄여 열로 바인딩 된다.
리스트는 데이터 프레임으로 변환할수 없다.

```{r}
as.data.frame(vector_1)
as.data.frame(matrix_1)
as.data.frame(dataframe_1)
as.data.frame(array_1)
```

벡터와 행렬을 어레이로 바꾸는 경우 그대로 변환된다.
데이터프레임은 어레이로 변환할수 없다.
리스트를 어레이로 바꾸는 경우 거의 동일하게 변환되나 일부 값이 변형된다.

```{r}
as.array(vector_1)
as.array(matrix_1)
as.array(list_1)
```


벡터와 행렬, 어레이를 리스트로 바꾸는 경우 각 값들이 벡터로 변형된 후 리스트에 각각 한 깊이별로 할당 된다.
데이터프레임을 리스트로 바꾸는 경우 각 열에 하나의 깊이로 변환된다.
```{r}
as.list(vector_1)
as.list(matrix_1)
as.list(dataframe_1)
as.list(array_1)
```


이로써 R의 자료형과 구조에 대해서 모두 살펴보았다. 다음에는 Python의 자료구조 특히 분석에 사용되는 pandas의 자료 구조를 중심으로 살펴본다. 끝으로 RStudio 사용시 필요한 몇가지 단축키와 기본설정을 정리했다.


``` {r}
# 주석 : Ctrl + Shift + C
# 한글 encording UTF-8
# 자동줄바꿈  Soft-wrap R source file옵션
# objects() 객체 리스트 출력력
# R은 열단위로 편성되는 것을 기본 설정
# 함수 내부에 화살표(' <- ')를 사용하면 변수를 할당된 변수가 추가적으로 생성됨, 일반적인 옵션값 설정에서는 등호(' = ')가 선호
```